<!DOCTYPE html>
<html lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="color-scheme" content="dark light">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- Locally cached version of https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,200..900;1,200..900&family=Inconsolata:wght@200..900&display=swap -->
  <link rel="stylesheet" href="fonts.css">
  <link rel="preload" crossorigin href="https://fonts.gstatic.com/s/crimsonpro/v24/q5uBsoa5M_tv7IihmnkabARekYNwDeChrlU.woff2" as=font type="font/woff2">
  <link rel="preload" crossorigin href="https://fonts.gstatic.com/s/crimsonpro/v24/q5uDsoa5M_tv7IihmnkabARboYF6CsKj.woff2" as=font type="font/woff2">
  <link rel="preload" crossorigin href="https://fonts.gstatic.com/s/inconsolata/v32/QlddNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLyya15IDhunA.woff2" as=font type="font/woff2">
  <link rel="preload" crossorigin href="https://fonts.gstatic.com/s/inconsolata/v32/QlddNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLyya15.woff2" as=font type="font/woff2">
  <link rel="preload" crossorigin href="https://fonts.gstatic.com/s/crimsonpro/v27/q5uDsoa5M_tv7IihmnkabARboYE.woff2" as=font type="font/woff2">
  <link rel="preload" crossorigin href="https://fonts.gstatic.com/s/crimsonpro/v27/q5uBsoa5M_tv7IihmnkabARekYNwDQ.woff2" as=font type="font/woff2">
  <link rel="preload" crossorigin href="https://fonts.gstatic.com/s/spectral/v13/rnCr-xNNww_2s0amA9M5knjsS_ul.woff2" as=font type="font/woff2">

  <meta name="generator" content="pandoc" />



  <link rel="prev" href="html.html" />
  <link rel="next" href="styles.html" />

  <link rel="stylesheet" href="book.css" />
  <link rel="alternate" type="application/rss+xml" href="rss.xml" title="Web Browser Engineering">
  <link rel="shortcut icon" href="favicon.ico">

  <title>Laying Out Pages | Web Browser Engineering</title>

</head>

<body>


<header>
<h1 class="title">Laying Out Pages</h1>
<a href="https://twitter.com/browserbook">Twitter</a> ·
<a href="https://browserbook.substack.com/">Blog</a> ·
<a href="https://github.com/browserengineering/book/discussions">Discussions</a>
</header>

<nav class="links">
  Chapter 5 of <a href="index.html" title="Table of Contents">Web Browser Engineering</a>.
  <a rel="prev" title="Previous chapter" href="html.html">&lt;</a>
  <a rel="next" title="Next chapter" href="styles.html">&gt;</a>
</nav>


<aside class="ad">
  <div class="wide">
    <img src="im/cover.jpg" alt="The cover for Web Browser Engineering, published by Oxford University Press. Click the cover to buy a copy.">
    <a class="preorder" href="https://global.oup.com/academic/product/web-browser-engineering-9780198913863">Buy a copy »</a>
  </div>
  <p class="narrow">
    <span><i>Web Browser Engineering</i> is now available.</span>
    <a href="https://global.oup.com/academic/product/web-browser-engineering-9780198913863">Buy a copy »</a>
  </p>
</aside>


<nav id="toc">
<ul>
<li><a href="#the-layout-tree">The Layout Tree</a></li>
<li><a href="#block-layout">Block Layout</a></li>
<li><a href="#size-and-position">Size and Position</a></li>
<li><a href="#recursive-painting">Recursive Painting</a></li>
<li><a href="#backgrounds">Backgrounds</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#outline">Outline</a></li>
<li><a href="#exercises">Exercises</a></li>
</ul>
</nav>

<p>So far, layout has been a linear process that handles open tags and
close tags independently. But web pages are trees, and look like them:
borders and backgrounds visually nest inside one another. To support
that, this chapter switches to <em>tree-based layout</em>, where the
tree of elements is transformed into a tree of <em>layout objects</em>
before drawing. In the process, we’ll make web pages more colorful with
backgrounds.</p>
<h1 id="the-layout-tree">The Layout Tree</h1>
<p>Right now, our browser lays out an element’s open and close tags
separately. Both tags modify global state, like the
<code>cursor_x</code> and <code>cursor_y</code> variables, but they
aren’t otherwise connected, and information about the element as a
whole, like its width and height, is never computed. That makes it
pretty hard to draw a background behind an element, let alone more
complicated visual effects. So web browsers structure layout
differently.</p>
<p>In a browser, layout is about producing a <em>layout tree</em>, whose
nodes are <em>layout objects</em>, each associated with an HTML
element<span class="note-container"><span class="note">Elements like
<code>&lt;script&gt;</code> don’t generate layout objects, and some
elements generate multiple layout objects (<code>&lt;li&gt;</code>
elements have an extra one for the bullet point!), but mostly it’s one
layout object each.</span></span> and each with a size and a position.
The browser walks the HTML tree to produce the layout tree, then
computes the size and position for each layout object, and finally draws
each layout object to the screen.</p>
<p>Let’s start by looking at how the existing <code>Layout</code> class
is used:</p>
<div class="sourceCode" id="cb1" data-file="lab4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Browser:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> load(<span class="va">self</span>, url):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.display_list <span class="op">=</span> Layout(<span class="va">self</span>.nodes).display_list</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">#...</span></span></code></pre></div>
<p>Here, a <code>Layout</code> object is created briefly and then thrown
away. Let’s instead make it the beginning of our layout tree by storing
it in a <code>Browser</code> field:</p>
<div class="sourceCode" id="cb2" data-replace="Layout/DocumentLayout"
data-dropline="display_list"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Browser:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> load(<span class="va">self</span>, url):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.document <span class="op">=</span> Layout(<span class="va">self</span>.nodes)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.document.layout()</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.display_list <span class="op">=</span> <span class="va">self</span>.document.display_list</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">#...</span></span></code></pre></div>
<p>Note that I’ve renamed the <code>Layout</code> constructor to a
<code>layout</code> method, so that constructing a layout object and
actually laying it out can be different steps. The constructor now just
stores the node it was passed:</p>
<div class="sourceCode" id="cb3" data-replace="Layout/BlockLayout"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Layout:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, node):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.node <span class="op">=</span> node</span></code></pre></div>
<p>So far, we still don’t have a tree—we just have a single
<code>Layout</code> object. To make it into a tree, we’ll need to add
child and parent pointers. I’m also going to add a pointer to the
previous sibling, because that’ll be useful for computing sizes and
positions later:</p>
<div class="sourceCode" id="cb4" data-replace="Layout/BlockLayout"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Layout:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, node, parent, previous):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.node <span class="op">=</span> node</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> parent</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.previous <span class="op">=</span> previous</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span></code></pre></div>
<p>That said, requiring a <code>parent</code> and <code>previous</code>
object now makes it tricky to construct a <code>Layout</code> object in
<code>Browser</code>, since the root of the layout tree obviously can’t
have a parent. To rectify that, let me add a second kind of layout
object to serve as the root of the layout tree.<span
class="note-container"><span class="note">I don’t want to just pass
<code>None</code> for the parent, because the root layout object also
computes its size and position differently, as we’ll see later in this
chapter.</span></span> I think of that root as the document itself, so
let’s call it <code>DocumentLayout</code>:</p>
<div class="sourceCode" id="cb5" data-replace="%20Layout/%20BlockLayout"
data-dropline="display_list"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DocumentLayout:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, node):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.node <span class="op">=</span> node</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> Layout(<span class="va">self</span>.node, <span class="va">self</span>, <span class="va">None</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children.append(child)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        child.layout()</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.display_list <span class="op">=</span> child.display_list</span></code></pre></div>
<p>Note an interesting thing about this new <code>layout</code> method:
its role is to <em>create</em> the child layout objects and then
<em>recursively</em> call their <code>layout</code> methods. This is a
common pattern for constructing trees; we’ll be seeing it a lot
throughout this book.</p>
<p>Now when we construct a <code>DocumentLayout</code> object inside
<code>load</code>, we’ll be building a tree; a very short tree, more of
a stump (just the “document” and the HTML element below it), but a tree
nonetheless!</p>
<p>By the way, since we now have <code>DocumentLayout</code>, let’s
rename <code>Layout</code> so it’s less ambiguous. I like
<code>BlockLayout</code> as a name, because we ultimately want it to
represent a block of text, like a paragraph or a heading:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span></code></pre></div>
<p>Make sure to rename the <code>Layout</code> constructor call in
<code>DocumentLayout</code> as well. As always, test your browser and
make sure that after all of these refactors, everything still works.</p>
<div class="further">
<p>The layout tree isn’t accessible to web developers, so it hasn’t been
standardized, and its structure differs between browsers. Even the names
don’t match! Chrome calls it a <a
href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">layout
tree</a>, Safari a <a
href="https://webkit.org/blog/114/webcore-rendering-i-the-basics/">render
tree</a>, and Firefox a <a
href="https://wiki.mozilla.org/Gecko:Key_Gecko_Structures_And_Invariants">frame
tree</a>.</p>
</div>
<h1 id="block-layout">Block Layout</h1>
<p>So far, we’ve focused on text layout—and text is laid out
horizontally in lines.<span class="note-container"><span class="note">In
European languages, at least!</span></span> But web pages are really
constructed out of larger blocks, like headings, paragraphs, and menus,
that stack vertically one after another. We need to add support for this
kind of layout to our browser, and the way we’re going to do that
involves expanding on the layout tree we’ve already built.</p>
<p>The core idea is that we’ll have a whole tree of
<code>BlockLayout</code> objects (with a <code>DocumentLayout</code> at
the root). Some will represent leaf blocks that contain text, and
they’ll lay out their contents the way we’ve already implemented. But
there will also be new, intermediate <code>BlockLayout</code>s with
<code>BlockLayout</code> children, and they will stack their children
vertically. (An example is shown in Figure 1. A widget above it lets you
play with how block layout leads to different visual output.)</p>
<div>
<iframe class="widget" src="widgets/layout-container-example.html?embed=true" data-big-height="490px" data-small-height="860px"></iframe>
</div>
<div class="center">
<figure>
<img src="im/layout-tree-2.gif"
alt="Figure 1: An example of an HTML tree and the corresponding layout tree." />
<figcaption aria-hidden="true">Figure 1: An example of an HTML tree and
the corresponding layout tree.</figcaption>
</figure>
</div>
<p>To create these intermediate <code>BlockLayout</code> children, we
can use a loop like this:</p>
<div class="sourceCode" id="cb7"
data-replace="layout_intermediate/layout"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout_intermediate(<span class="va">self</span>):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        previous <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.node.children:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            <span class="bu">next</span> <span class="op">=</span> BlockLayout(child, <span class="va">self</span>, previous)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children.append(<span class="bu">next</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            previous <span class="op">=</span> <span class="bu">next</span></span></code></pre></div>
<p>I’ve called this method <code>layout_intermediate</code>, but only so
you can add it to the code right away and then compare it with the
existing <code>recurse</code> method.</p>
<p>This code is tricky, so read it carefully. It involves two trees: the
HTML tree, which <code>node</code> and <code>child</code> point to; and
the layout tree, which <code>self</code>, <code>previous</code>, and
<code>next</code> point to. The two trees have similar structure, so
it’s easy to get confused. But remember that this code constructs the
layout tree from the HTML tree, so it reads from
<code>node.children</code> (in the HTML tree) and writes to
<code>self.children</code> (in the layout tree).</p>
<p>So we have two ways to lay out an element: either calling
<code>recurse</code> and <code>flush</code>, or this
<code>layout_intermediate</code> function. To determine which one a
layout object should use, we’ll need to know what kind of content its
HTML node contains: <em>inline</em> text and text-related tags like
<code>&lt;b&gt;</code>, or <em>blocks</em> like <code>&lt;p&gt;</code>
and <code>&lt;h1&gt;</code>. Let’s add a <code>layout_mode</code> method
that computes which is which:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout_mode(<span class="va">self</span>):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.node, Text):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;inline&quot;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">any</span>([<span class="bu">isinstance</span>(child, Element) <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                  child.tag <span class="kw">in</span> BLOCK_ELEMENTS</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                  <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.node.children]):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;block&quot;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.node.children:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;inline&quot;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;block&quot;</span></span></code></pre></div>
<p>Here, the list of <code>BLOCK_ELEMENTS</code> is basically what you
expect, a list of all the tags that describe blocks and containers:<span
class="note-container"><span class="note">Taken from the <a
href="https://html.spec.whatwg.org/multipage/#toc-semantics">HTML living
standard</a>.</span></span></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>BLOCK_ELEMENTS <span class="op">=</span> [</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;html&quot;</span>, <span class="st">&quot;body&quot;</span>, <span class="st">&quot;article&quot;</span>, <span class="st">&quot;section&quot;</span>, <span class="st">&quot;nav&quot;</span>, <span class="st">&quot;aside&quot;</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;h1&quot;</span>, <span class="st">&quot;h2&quot;</span>, <span class="st">&quot;h3&quot;</span>, <span class="st">&quot;h4&quot;</span>, <span class="st">&quot;h5&quot;</span>, <span class="st">&quot;h6&quot;</span>, <span class="st">&quot;hgroup&quot;</span>, <span class="st">&quot;header&quot;</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;footer&quot;</span>, <span class="st">&quot;address&quot;</span>, <span class="st">&quot;p&quot;</span>, <span class="st">&quot;hr&quot;</span>, <span class="st">&quot;pre&quot;</span>, <span class="st">&quot;blockquote&quot;</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ol&quot;</span>, <span class="st">&quot;ul&quot;</span>, <span class="st">&quot;menu&quot;</span>, <span class="st">&quot;li&quot;</span>, <span class="st">&quot;dl&quot;</span>, <span class="st">&quot;dt&quot;</span>, <span class="st">&quot;dd&quot;</span>, <span class="st">&quot;figure&quot;</span>,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;figcaption&quot;</span>, <span class="st">&quot;main&quot;</span>, <span class="st">&quot;div&quot;</span>, <span class="st">&quot;table&quot;</span>, <span class="st">&quot;form&quot;</span>, <span class="st">&quot;fieldset&quot;</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;legend&quot;</span>, <span class="st">&quot;details&quot;</span>, <span class="st">&quot;summary&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>Our <code>layout_mode</code> method has to handle one tricky case,
where a node contains both block children like a <code>&lt;p&gt;</code>
element and also text children like a text node or a
<code>&lt;b&gt;</code> element. It’s probably best to think of this as a
kind of error on the part of the web developer. And just like with
implicit tags in <a href="html.html">Chapter 4</a>, we need a repair
mechanism to make sense of the situation; I’ve chosen to use block mode
in this case.<span class="note-container"><span class="note">In real
browsers, that repair mechanism is called “<a
href="https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model#anonymous_boxes">anonymous
block boxes</a>” and is more complex than what’s described here; see
Exercise 5-5.</span></span></p>
<p>So now <code>BlockLayout</code> can determine what kind of layout to
do based on the <code>layout_mode</code> of its HTML node:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        mode <span class="op">=</span> <span class="va">self</span>.layout_mode()</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mode <span class="op">==</span> <span class="st">&quot;block&quot;</span>:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>            previous <span class="op">=</span> <span class="va">None</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.node.children:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                <span class="bu">next</span> <span class="op">=</span> BlockLayout(child, <span class="va">self</span>, previous)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.children.append(<span class="bu">next</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>                previous <span class="op">=</span> <span class="bu">next</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cursor_x <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cursor_y <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.weight <span class="op">=</span> <span class="st">&quot;normal&quot;</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.style <span class="op">=</span> <span class="st">&quot;roman&quot;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.size <span class="op">=</span> <span class="dv">12</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.line <span class="op">=</span> []</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.recurse(<span class="va">self</span>.node)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.flush()</span></code></pre></div>
<p>Finally, since <code>BlockLayout</code>s can now have children, the
<code>layout</code> method next needs to recursively call
<code>layout</code> so those children can construct their children, and
so on recursively:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.children:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            child.layout()</span></code></pre></div>
<p>Our browser is now constructing a whole tree of
<code>BlockLayout</code> objects; you can use <code>print_tree</code> to
see this tree in the <code>Browser</code>’s <code>load</code> method.
You’ll see that large web pages like this chapter produce large and
complex layout trees! Now we need each of these <code>BlockLayout</code>
objects to have a size and position somewhere on the page.</p>
<div class="further">
<p>In CSS, the layout mode is set by the <a
href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code>
property</a>. The oldest CSS layout modes, like <code>inline</code> and
<code>block</code>, are set on the children instead of the parent, which
leads to hiccups like <a
href="https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model#anonymous_boxes">anonymous
block boxes</a>. Newer properties like <code>inline-block</code>,
<code>flex</code>, and <code>grid</code> are set on the parent, which
avoids this kind of error.</p>
</div>
<h1 id="size-and-position">Size and Position</h1>
<p>In the <a href="html.html">previous chapter</a>, the
<code>Layout</code> object was responsible for the whole web page, so it
just laid out its content starting at the top of the page. Now that we
have multiple <code>BlockLayout</code> objects each containing a
different paragraph of text, we’re going to need to do things a little
differently, computing a size and position for each layout object
independently.</p>
<p>Let’s add <code>x</code>, <code>y</code>, <code>width</code>, and
<code>height</code> fields for each layout object type:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, node, parent, previous):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.width <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.height <span class="op">=</span> <span class="va">None</span></span></code></pre></div>
<p>Do the same for <code>DocumentLayout</code>. Now we need to update
the <code>layout</code> method to use these fields.</p>
<p>Let’s start with <code>cursor_x</code> and <code>cursor_y</code>.
Instead of having them denote absolute positions on the page, let’s make
them relative to the <code>BlockLayout</code>’s <code>x</code> and
<code>y</code>. So they now need to start from <code>0</code> instead of
<code>HSTEP</code> and <code>VSTEP</code>, in both <code>layout</code>
and <code>flush</code>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cursor_x <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cursor_y <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> flush(<span class="va">self</span>):</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cursor_x <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Since these fields are now relative, we’ll need to add the block’s
<code>x</code> and <code>y</code> position in <code>flush</code> when
computing the display list:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> flush(<span class="va">self</span>):</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> rel_x, word, font <span class="kw">in</span> <span class="va">self</span>.line:</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> <span class="va">self</span>.x <span class="op">+</span> rel_x</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> <span class="va">self</span>.y <span class="op">+</span> baseline <span class="op">-</span> font.metrics(<span class="st">&quot;ascent&quot;</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.display_list.append((x, y, word, font))</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Similarly, to wrap lines, we can’t compare <code>cursor_x</code> to
<code>WIDTH</code>, because <code>cursor_x</code> is a relative position
while <code>WIDTH</code> is an absolute position; instead, we’ll wrap
lines when <code>cursor_x</code> reaches the block’s
<code>width</code>:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> word(<span class="va">self</span>, word):</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.cursor_x <span class="op">+</span> w <span class="op">&gt;</span> <span class="va">self</span>.width:</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>            <span class="co"># ...</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>So now that leaves us with the problem of computing these
<code>x</code>, <code>y</code>, and <code>width</code> fields. Let’s
recall that <code>BlockLayout</code>s represent blocks of text like
paragraphs or headings, and are stacked vertically one atop another.
That means each one starts at its parent’s left edge and goes all the
way across its parent:<span class="note-container"><span class="note">In
the <a href="styles.html">next chapter</a>, we’ll add support for
author-defined styles, which in real browsers modify these layout rules
by setting custom widths or changing how <em>x</em> and <em>y</em>
positions are computed.</span></span></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="va">self</span>.parent.x</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.width <span class="op">=</span> <span class="va">self</span>.parent.width</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>A layout object’s vertical position depends on whether there’s a
previous sibling. If there is one, the layout object starts right after
it; otherwise, it starts at its parent’s top edge:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.previous:</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.y <span class="op">=</span> <span class="va">self</span>.previous.y <span class="op">+</span> <span class="va">self</span>.previous.height</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.y <span class="op">=</span> <span class="va">self</span>.parent.y</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Finally, height is a little tricky. A <code>BlockLayout</code> that
contains other blocks should be tall enough to contain all of its
children, so its height should be the sum of its children’s heights:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mode <span class="op">==</span> <span class="st">&quot;block&quot;</span>:</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.height <span class="op">=</span> <span class="bu">sum</span>([</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                child.height <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.children])</span></code></pre></div>
<p>However, a <code>BlockLayout</code> that contains text doesn’t have
children; instead, it needs to be tall enough to contain all its text,
which we can conveniently read off from <code>cursor_y</code>:<span
class="note-container"><span class="note">Since the height is just equal
to <code>cursor_y</code>, why not rename <code>cursor_y</code> to
<code>height</code> instead? You could, it would work fine, but I would
rather not. As you can see from, say, the <code>y</code> computation,
the <code>height</code> field is a public field, read by other layout
objects to compute their positions. As such, I’d rather make sure it
<em>always</em> has the right value, whereas <code>cursor_y</code>
changes as we lay out a paragraph of text and therefore sometimes has
the “wrong” value. Keeping these two fields separate avoids a whole
class of nasty bugs where the <code>height</code> field is read “too
soon” and therefore gets the wrong value.</span></span></p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.height <span class="op">=</span> <span class="va">self</span>.cursor_y</span></code></pre></div>
<p>These rules seem simple enough, but there’s a subtlety here I have to
explain. Consider the <code>x</code> position. To compute a block’s
<code>x</code> position, the <code>x</code> position of its parent block
must <em>already</em> have been computed. So a block’s <code>x</code>
must therefore be computed before its children’s <code>x</code>. That
means the <code>x</code> computation has to go <em>before</em> the
recursive <code>layout</code> call.</p>
<p>On the other hand, an element’s <code>height</code> field depends on
its children’s heights. So while <code>x</code> must be computed
<em>before</em> the recursive call, <code>height</code> has to be
computed <em>after</em>. Similarly, since the <code>y</code> position of
a block depends on its previous sibling’s <code>y</code> position, the
recursive <code>layout</code> calls have to start at the first sibling
and iterate through the list forward.</p>
<p>That is, the <code>layout</code> method should perform its steps in
this order (see Figure 2):</p>
<ul>
<li>When <code>layout</code> is called, it first computes the
<code>width</code>, <code>x</code>, and <code>y</code> fields, reading
from the <code>parent</code> and <code>previous</code> layout
objects.</li>
<li>Next, it creates a child layout object for each child element.</li>
<li>Then, the child layout nodes are recursively laid out by calling
their <code>layout</code> methods.</li>
<li>Finally, <code>layout</code> computes the <code>height</code> field,
reading from the child layout objects.</li>
</ul>
<div>
<p>You can see these steps in action in this widget:</p>
<iframe class="widget" src="widgets/lab5-propagate.html" height="204"></iframe>
</div>
<div class="center">
<figure>
<img src="im/layout-order.png"
alt="Figure 2: A flowchart showing how widths are computed top-down, from parent to child, while heights are computed bottom-up, from child to parent." />
<figcaption aria-hidden="true">Figure 2: A flowchart showing how widths
are computed top-down, from parent to child, while heights are computed
bottom-up, from child to parent.</figcaption>
</figure>
</div>
<p>This kind of dependency reasoning is crucial to layout and more
broadly to any kind of computation on trees. If you get the order of
operations wrong, some layout object will try to read a value that
hasn’t been computed yet, and the browser will have a bug. We’ll come
back to this issue of dependencies <a href="invalidation.html">in
Chapter 16</a>, where it will become even more important.</p>
<p><code>DocumentLayout</code> needs some layout code too, though since
the document always starts in the same place it’s pretty simple:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DocumentLayout:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> layout(<span class="va">self</span>):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.width <span class="op">=</span> WIDTH <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>HSTEP</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> HSTEP</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> VSTEP</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        child.layout()</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.height <span class="op">=</span> child.height</span></code></pre></div>
<p>Note that there’s some padding around the contents—<code>HSTEP</code>
on the left and right, and <code>VSTEP</code> above and below. That’s so
the text won’t run into the very edge of the window and get cut off.</p>
<p>Anyway, with all of the sizes and positions now computed correctly,
our browser should display all of the text on the page in the right
places.</p>
<div class="further">
<p>Formally, computations on a tree like this can be described by an <a
href="https://en.wikipedia.org/wiki/Attribute_grammar">attribute
grammar</a>. Attribute grammar engines analyze dependencies between
different attributes to determine the right order to traverse the tree
and calculate each attribute.</p>
</div>
<h1 id="recursive-painting">Recursive Painting</h1>
<p>Our <code>layout</code> method is now doing quite a bit of work:
computing sizes and positions; creating child layout objects;
recursively laying out those child layout objects; and aggregating the
display lists so the text can be drawn to the screen. This is a bit
messy, so let’s take a moment to extract just one part of this, the
display list part. Along the way, we can stop copying the display list
contents over and over again as we go up the layout tree.</p>
<p>I think it’s most convenient to do that by adding a
<code>paint</code> function to each layout object, whose return value is
the display list entries for that object. Then there is a separate
function, <code>paint_tree</code>, that recursively calls
<code>paint</code> on all layout objects:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> paint_tree(layout_object, display_list):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    display_list.extend(layout_object.paint())</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> child <span class="kw">in</span> layout_object.children:</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        paint_tree(child, display_list)</span></code></pre></div>
<p>For <code>DocumentLayout</code>, there is nothing to paint:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DocumentLayout:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> paint(<span class="va">self</span>):</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span></code></pre></div>
<p>You can now delete the line that computes a
<code>DocumentLayout</code>’s <code>display_list</code> field.</p>
<p>For a <code>BlockLayout</code> object, we need to copy over the
<code>display_list</code> field that it computes during
<code>recurse</code> and <code>flush</code>:<span
class="note-container"><span class="note">And again, delete the line
that computes a <code>BlockLayout</code>’s <code>display_list</code>
field by copying from child layout objects.</span></span></p>
<div class="sourceCode" id="cb23" data-expected="False"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> paint(<span class="va">self</span>):</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.display_list</span></code></pre></div>
<p>Now the browser can use <code>paint_tree</code> to collect its own
<code>display_list</code> variable:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Browser:</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> load(<span class="va">self</span>, url):</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.display_list <span class="op">=</span> []</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        paint_tree(<span class="va">self</span>.document, <span class="va">self</span>.display_list)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.draw()</span></code></pre></div>
<p>Check it out: our browser is now using fancy tree-based layout! I
recommend pausing to test and debug. Tree-based layout is powerful but
complex, and we’re about to add more features. Stable foundations make
for comfortable houses.</p>
<div class="further">
<p>Layout trees are common <a
href="https://book.huihoo.com/debian-gnu-linux-desktop-survival-guide/Widget_Tree.html">in
graphical user interface (GUI) frameworks</a>, but there are other ways
to structure layout, such as constraint-based layout. TeX’s <a
href="https://www.overleaf.com/learn/latex/Articles/Boxes_and_Glue%3A_A_Brief%2C_but_Visual%2C_Introduction_Using_LuaTeX">boxes
and glue</a> and iOS’s <a
href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html">auto-layout</a>
are two examples of this alternative paradigm.</p>
</div>
<h1 id="backgrounds">Backgrounds</h1>
<p>Browsers use the layout tree a lot,<span class="note-container"><span
class="note">For example, in <a href="chrome.html">Chapter 7</a>, we’ll
use the size and position of each link to figure out which one the user
clicked on.</span></span> and one simple and visually compelling use
case is drawing backgrounds.</p>
<p>Backgrounds are rectangles, so our first task is putting rectangles
in the display list. Right now, the display list is a list of words to
draw to the screen, but we can conceptualize it instead as a list of
<em>commands</em>, of which there is currently only one type. We now
want two types of commands:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DrawText:</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x1, y1, text, font):</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.top <span class="op">=</span> y1</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> x1</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.text <span class="op">=</span> text</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.font <span class="op">=</span> font</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DrawRect:</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x1, y1, x2, y2, color):</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.top <span class="op">=</span> y1</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> x1</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bottom <span class="op">=</span> y2</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> x2</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.color <span class="op">=</span> color</span></code></pre></div>
<p>Now <code>BlockLayout</code> must add <code>DrawText</code> objects
for each word it wants to draw, but only in inline mode:<span
class="note-container"><span class="note">Why not change the
<code>display_list</code> field inside a <code>BlockLayout</code> to
contain <code>DrawText</code> commands directly? I suppose you could,
but I think it’s cleaner to create all of the draw commands in
<code>paint</code>.</span></span></p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> paint(<span class="va">self</span>):</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        cmds <span class="op">=</span> []</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.layout_mode() <span class="op">==</span> <span class="st">&quot;inline&quot;</span>:</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x, y, word, font <span class="kw">in</span> <span class="va">self</span>.display_list:</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>                cmds.append(DrawText(x, y, word, font))</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cmds</span></code></pre></div>
<p>But it can also add a <code>DrawRect</code> command to draw a
background. Let’s add a gray background to <code>pre</code> tags (which
are used for code examples):</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BlockLayout:</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> paint(<span class="va">self</span>):</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.node, Element) <span class="kw">and</span> <span class="va">self</span>.node.tag <span class="op">==</span> <span class="st">&quot;pre&quot;</span>:</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>            x2, y2 <span class="op">=</span> <span class="va">self</span>.x <span class="op">+</span> <span class="va">self</span>.width, <span class="va">self</span>.y <span class="op">+</span> <span class="va">self</span>.height</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>            rect <span class="op">=</span> DrawRect(<span class="va">self</span>.x, <span class="va">self</span>.y, x2, y2, <span class="st">&quot;gray&quot;</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>            cmds.append(rect)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span></code></pre></div>
<p>Make sure this code comes <em>before</em> the loop that adds
<code>DrawText</code> objects: the background has to be drawn
<em>below</em> that text. Note also that <code>paint_tree</code> calls
<code>paint</code> before recursing into the subtree, so the subtree
also paints on top of this background, as desired.</p>
<p>With the display list filled out, we need to draw each graphics
command. Let’s add an <code>execute</code> method for this. On
<code>DrawText</code> it calls <code>create_text</code>:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DrawText:</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, scroll, canvas):</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>        canvas.create_text(</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.left, <span class="va">self</span>.top <span class="op">-</span> scroll,</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>            text<span class="op">=</span><span class="va">self</span>.text,</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>            font<span class="op">=</span><span class="va">self</span>.font,</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>            anchor<span class="op">=</span><span class="st">&#39;nw&#39;</span>)</span></code></pre></div>
<p>Note that <code>execute</code> takes the scroll amount as a
parameter; this way, each graphics command does the relevant coordinate
conversion itself. <code>DrawRect</code> does the same with
<code>create_rectangle</code>:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DrawRect:</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> execute(<span class="va">self</span>, scroll, canvas):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        canvas.create_rectangle(</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.left, <span class="va">self</span>.top <span class="op">-</span> scroll,</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.right, <span class="va">self</span>.bottom <span class="op">-</span> scroll,</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>            width<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>            fill<span class="op">=</span><span class="va">self</span>.color)</span></code></pre></div>
<p>By default, <code>create_rectangle</code> draws a one-pixel black
border, which we don’t want for backgrounds, so make sure to pass
<code>width=0</code>.</p>
<p>We still want to skip offscreen graphics commands, so let’s add a
<code>bottom</code> field to <code>DrawText</code> so we know when to
skip those:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x1, y1, text, font):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.bottom <span class="op">=</span> y1 <span class="op">+</span> font.metrics(<span class="st">&quot;linespace&quot;</span>)</span></code></pre></div>
<p>The browser’s <code>draw</code> method now just uses <code>top</code>
and <code>bottom</code> to decide which commands to
<code>execute</code>:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Browser:</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> draw(<span class="va">self</span>):</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.canvas.delete(<span class="st">&quot;all&quot;</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> cmd <span class="kw">in</span> <span class="va">self</span>.display_list:</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cmd.top <span class="op">&gt;</span> <span class="va">self</span>.scroll <span class="op">+</span> HEIGHT: <span class="cf">continue</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cmd.bottom <span class="op">&lt;</span> <span class="va">self</span>.scroll: <span class="cf">continue</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>            cmd.execute(<span class="va">self</span>.scroll, <span class="va">self</span>.canvas)</span></code></pre></div>
<p>Try your browser on a page—maybe <a
href="https://browser.engineering/layout.html">this chapter’s</a>—with
code snippets on it. You should see each code snippet set off with a
gray background.</p>
<p>Here’s one more cute benefit of tree-based layout: we now record the
height of the whole page. The browser can use that to avoid scrolling
past the bottom:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> scrolldown(<span class="va">self</span>, e):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    max_y <span class="op">=</span> <span class="bu">max</span>(<span class="va">self</span>.document.height <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>VSTEP <span class="op">-</span> HEIGHT, <span class="dv">0</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.scroll <span class="op">=</span> <span class="bu">min</span>(<span class="va">self</span>.scroll <span class="op">+</span> SCROLL_STEP, max_y)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.draw()</span></code></pre></div>
<p>Note the <code>2*VSTEP</code>, to account for a <code>VSTEP</code> of
whitespace at the top and bottom of the page. With layout the <a
href="https://browser.engineering/">browser.engineering homepage</a> now
looks a bit better—see Figure 3.</p>
<p>So those are the basics of tree-based layout! In fact, as we’ll see
in the next two chapters, this is just one part of the layout tree’s
central role in the browser. But before we get to that, we need to add
some styling capabilities to our browser.</p>
<div class="center">
<figure>
<img src="examples/example5-browserengineering-screenshot.png"
alt="Figure 3: https://browser.engineering/ viewed in this chapter’s version of the browser." />
<figcaption aria-hidden="true">Figure 3: https://browser.engineering/
viewed in this chapter’s version of the browser.</figcaption>
</figure>
</div>
<div class="further">
<p>The draft CSS <a
href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Painting_API/Guide">Painting
API</a> allows pages to extend the display list with new types of
commands, implemented in JavaScript. This makes it possible to use CSS
for styling with visually complex styling provided by a library.</p>
</div>
<h1 id="summary">Summary</h1>
<p>This chapter was a dramatic rewrite of our browser’s layout engine,
so:</p>
<ul>
<li>layout is now tree-based and produces a <em>layout tree</em>;</li>
<li>each node in the tree has one of two different <em>layout
modes</em>;</li>
<li>layout computes a size and position for each layout object;</li>
<li>the display list now contains generic commands;</li>
<li>source code snippets now have backgrounds.</li>
</ul>
<p>Tree-based layout makes it possible to dramatically expand our
browser’s styling capabilities. We’ll work on that in the <a
href="styles.html">next chapter</a>.</p>
<iframe class="widget" src="widgets/lab5-browser.html" height="400"></iframe>
<div id="signup">
<iframe src="https://browserbook.substack.com/embed" width="350" height="150" frameborder="0" scrolling="no"></iframe>
<a href="#" id="signup-close">Close</a>
</div>

<h1 id="outline">Outline</h1>
<p>The complete set of functions, classes, and methods in our browser
should look something like this:</p>
<div class="cmd python outline">
<code class=line><span class=kw>class</span> URL:
<code class=line>    <span class=kw>def</span> __init__(url)
</code>
<code class=line>    <span class=kw>def</span> request()
</code>
</code>
<code class=line><span class=kw>class</span> Text:
<code class=line>    <span class=kw>def</span> __init__(text, parent)
</code>
<code class=line>    <span class=kw>def</span> __repr__()
</code>
</code>
<code class=line><span class=kw>class</span> Element:
<code class=line>    <span class=kw>def</span> __init__(tag, attributes, parent)
</code>
<code class=line>    <span class=kw>def</span> __repr__()
</code>
</code>
<code class=line><span class=kw>def</span> print_tree(node, indent)
</code>
<code class=line><span class=kw>class</span> HTMLParser:
<code class=line>    SELF_CLOSING_TAGS
</code>
<code class=line>    HEAD_TAGS
</code>
<code class=line>    <span class=kw>def</span> __init__(body)
</code>
<code class=line>    <span class=kw>def</span> parse()
</code>
<code class=line>    <span class=kw>def</span> get_attributes(text)
</code>
<code class=line>    <span class=kw>def</span> add_text(text)
</code>
<code class=line>    <span class=kw>def</span> add_tag(tag)
</code>
<code class=line>    <span class=kw>def</span> implicit_tags(tag)
</code>
<code class=line>    <span class=kw>def</span> finish()
</code>
</code>
<code class=line>FONTS
</code>
<code class=line><span class=kw>def</span> get_font(size, weight, style)
</code>
<code class=line>WIDTH, HEIGHT
</code>
<code class=line>HSTEP, VSTEP
</code>
<code class=line>BLOCK_ELEMENTS
</code>
<code class=line><span class=kw>class</span> DocumentLayout:
<code class=line>    <span class=kw>def</span> __init__(node)
</code>
<code class=line>    <span class=kw>def</span> layout()
</code>
<code class=line>    <span class=kw>def</span> paint()
</code>
</code>
<code class=line><span class=kw>class</span> BlockLayout:
<code class=line>    <span class=kw>def</span> __init__(node, parent, previous)
</code>
<code class=line>    <span class=kw>def</span> layout_mode()
</code>
<code class=line>    <span class=kw>def</span> layout()
</code>
<code class=line>    <span class=kw>def</span> recurse(tree)
</code>
<code class=line>    <span class=kw>def</span> open_tag(tag)
</code>
<code class=line>    <span class=kw>def</span> close_tag(tag)
</code>
<code class=line>    <span class=kw>def</span> flush()
</code>
<code class=line>    <span class=kw>def</span> word(word)
</code>
<code class=line>    <span class=kw>def</span> paint()
</code>
</code>
<code class=line><span class=kw>class</span> DrawText:
<code class=line>    <span class=kw>def</span> __init__(x1, y1, text, font)
</code>
<code class=line>    <span class=kw>def</span> execute(scroll, canvas)
</code>
</code>
<code class=line><span class=kw>class</span> DrawRect:
<code class=line>    <span class=kw>def</span> __init__(x1, y1, x2, y2, color)
</code>
<code class=line>    <span class=kw>def</span> execute(scroll, canvas)
</code>
</code>
<code class=line><span class=kw>def</span> paint_tree(layout_object, display_list)
</code>
<code class=line>SCROLL_STEP
</code>
<code class=line><span class=kw>class</span> Browser:
<code class=line>    <span class=kw>def</span> __init__()
</code>
<code class=line>    <span class=kw>def</span> draw()
</code>
<code class=line>    <span class=kw>def</span> load(url)
</code>
<code class=line>    <span class=kw>def</span> scrolldown(e)
</code>
</code>

</div>
<h1 id="exercises">Exercises</h1>
<p>5-1 <em>Links bar</em>. At the top and bottom of the web version of
each chapter of this book there is a gray bar naming the chapter and
offering back and forward links. It is enclosed in a
<code>&lt;nav class="links"&gt;</code> tag. Have your browser give this
links bar the light gray background a real browser would.</p>
<p>5-2 <em>Hidden head</em>. There’s a good chance your browser is still
showing scripts, styles, and page titles at the top of every page you
visit. Make it so that the <code>&lt;head&gt;</code> element and its
contents are never displayed. Those elements should still be in the HTML
tree, but not in the layout tree.</p>
<p>5-3 <em>Bullets</em>. Add bullets to list items, which in HTML are
<code>&lt;li&gt;</code> tags. You can make them little squares, located
to the left of the list item itself. Also indent <code>&lt;li&gt;</code>
elements so the text inside the element is to the right of the bullet
point.</p>
<p>5-4 <em>Table of contents</em>. The web version of this book has a
table of contents at the top of each chapter, enclosed in a
<code>&lt;nav id="toc"&gt;</code> tag, which contains a list of links.
Add the text “Table of Contents”, with a gray background, above that
list. Don’t modify the lexer or parser.</p>
<p>5-5 <em>Anonymous block boxes</em>. Sometimes, an element has a mix
of text-like and container-like children. For example, in this HTML,</p>
<pre><code>&lt;div&gt;&lt;i&gt;Hello, &lt;/i&gt;&lt;b&gt;world!&lt;/b&gt;&lt;p&gt;So it began...&lt;/p&gt;&lt;/div&gt;</code></pre>
<p>the <code>&lt;div&gt;</code> element has three children: the
<code>&lt;i&gt;</code>, <code>&lt;b&gt;</code>, and
<code>&lt;p&gt;</code> elements. The first two are text-like; the last
is container-like. This is supposed to look like two paragraphs, one for
the <code>&lt;i&gt;</code> and <code>&lt;b&gt;</code> and the second for
the <code>&lt;p&gt;</code>. Make your browser do that. Specifically,
modify <code>BlockLayout</code> so it can be passed a sequence of
sibling nodes, instead of a single node. Then, modify the algorithm that
constructs the layout tree so that any sequence of text-like elements
gets made into a single <code>BlockLayout</code>.</p>
<p>5-6 <em>Run-ins</em>. A “run-in heading” is a heading that is drawn
as part of the next paragraph’s text.<span class="note-container"><span
class="note">The exercise names in this section could be considered
run-in headings. But since browser support for the
<code>display: run-in</code> property <a
href="https://caniuse.com/run-in">is poor</a>, this book actually
doesn’t use it; the headings are actually embedded in the next
paragraph.</span></span> Modify your browser to render
<code>&lt;h6&gt;</code> elements as run-in headings. You’ll need to
implement the previous exercise on anonymous block boxes, and then add a
special case for <code>&lt;h6&gt;</code> elements.</p>



<nav class="links">
  Chapter 5 of <a href="index.html" title="Table of Contents">Web Browser Engineering</a>.
  <a rel="prev" title="Previous chapter" href="html.html">&lt;</a>
  <a rel="next" title="Next chapter" href="styles.html">&gt;</a>
</nav>

<p>Did you find this chapter useful? <button id=feedback-button>Send us feedback!</button></p>

<footer>
  &copy; 2018&ndash;2023 <a href="https://pavpanchekha.com">Pavel Panchekha</a> &amp; <a href="https://twitter.com/chrishtr">Chris Harrelson</a>
</footer>

<script type="text/javascript" defer src="feedback.js"></script>
<script type="text/javascript" defer src="book.js"></script>

</body>
</html>
